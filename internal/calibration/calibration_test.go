package calibration

import (
	"bytes"
	"context"
	"io"
	"math/big"
	"os"
	"strings"
	"testing"
	"time"

	"github.com/agbru/fibcalc/internal/config"
	"github.com/agbru/fibcalc/internal/fibonacci"
)

// MockCalculator implements fibonacci.Calculator for testing calibration
type MockCalculator struct {
	name string
}

func (m *MockCalculator) Name() string {
	return m.name
}

func (m *MockCalculator) Calculate(ctx context.Context, progressChan chan<- fibonacci.ProgressUpdate, calcIndex int, n uint64, opts fibonacci.Options) (*big.Int, error) {
	// Simulate work duration dependent on threshold to test optimization logic
	// We use cumulative speedups to ensure the combination of optimal parameters
	// yields the strictly fastest time.

	// Base duration
	duration := 100 * time.Millisecond

	// Parallel speedup
	// We accept a range of values (2048-8192) to match adaptive environment logic
	if opts.ParallelThreshold >= 2048 && opts.ParallelThreshold <= 8192 {
		duration -= 40 * time.Millisecond
	}

	// FFT speedup
	if opts.FFTThreshold >= 750000 && opts.FFTThreshold <= 1000000 {
		duration -= 20 * time.Millisecond
	}

	// Strassen speedup
	if opts.StrassenThreshold >= 192 && opts.StrassenThreshold <= 512 {
		duration -= 20 * time.Millisecond
	}

	// Respect context timeout/cancellation
	select {
	case <-ctx.Done():
		return nil, ctx.Err()
	case <-time.After(duration):
	}

	return big.NewInt(1), nil
}

func TestAutoCalibrate(t *testing.T) {
	t.Parallel()
	// Mock registry
	registry := map[string]fibonacci.Calculator{
		"fast":   &MockCalculator{name: "fast"},
		"matrix": &MockCalculator{name: "matrix"},
	}

	cfg := config.AppConfig{
		Timeout:            1 * time.Second, // Short timeout for test
		CalibrationProfile: "",              // Don't use file
	}

	// We need to avoid loading real profiles during test, or ensure tmp path
	// The function LoadCachedCalibration uses LoadOrCreateProfile which might touch FS.
	// Best to use a temp file for profile path.
	tmpProfile := t.TempDir() + "/profile.json"
	cfg.CalibrationProfile = tmpProfile

	ctx := context.Background()

	// Run AutoCalibrate
	// It will run trials. Our mock sleeps.
	updatedCfg, success := AutoCalibrate(ctx, cfg, io.Discard, registry)

	if !success {
		t.Error("AutoCalibrate should succeed with mock calculator")
	}

	// Check if thresholds are updated (Mock logic makes 4096 fastest if generated in candidates)
	// Default candidates are generated by GenerateQuickParallelThresholds.
	// If 4096 is in candidates, it should be picked.
	// (Note: GenerateQuickParallelThresholds logic is internal but we assume standard values)

	if updatedCfg.Threshold == 0 {
		t.Error("Threshold should be set")
	}
}

func TestRunCalibration(t *testing.T) {
	t.Parallel()
	registry := map[string]fibonacci.Calculator{
		"fast": &MockCalculator{name: "fast"},
	}

	ctx := context.Background()
	exitCode := RunCalibration(ctx, io.Discard, registry)

	if exitCode != 0 { // ExitSuccess
		t.Errorf("RunCalibration failed with code %d", exitCode)
	}
}

func TestRunCalibrationMissingFast(t *testing.T) {
	t.Parallel()
	registry := map[string]fibonacci.Calculator{} // Empty

	ctx := context.Background()
	exitCode := RunCalibration(ctx, io.Discard, registry)

	if exitCode == 0 {
		t.Error("RunCalibration should fail if 'fast' calculator is missing")
	}
}

func TestLoadCachedCalibration(t *testing.T) {
	t.Parallel()

	t.Run("Nonexistent profile", func(t *testing.T) {
		t.Parallel()
		cfg := config.AppConfig{}
		_, success := LoadCachedCalibration(cfg, "nonexistent.json")
		if success {
			t.Error("Should return false for nonexistent profile")
		}
	})

	t.Run("Valid profile loaded", func(t *testing.T) {
		t.Parallel()
		tmpDir := t.TempDir()
		profilePath := tmpDir + "/profile.json"

		// Create a valid profile
		profile := NewProfile()
		profile.OptimalParallelThreshold = 4096
		profile.OptimalFFTThreshold = 1000000
		profile.OptimalStrassenThreshold = 256
		if err := profile.SaveProfile(profilePath); err != nil {
			t.Fatalf("Failed to save profile: %v", err)
		}

		cfg := config.AppConfig{
			Threshold:         2048,
			FFTThreshold:      500000,
			StrassenThreshold: 512,
		}

		updated, success := LoadCachedCalibration(cfg, profilePath)
		if !success {
			t.Error("Should return true for valid profile")
		}
		if updated.Threshold != 4096 {
			t.Errorf("Threshold = %d, want 4096", updated.Threshold)
		}
		if updated.FFTThreshold != 1000000 {
			t.Errorf("FFTThreshold = %d, want 1000000", updated.FFTThreshold)
		}
		if updated.StrassenThreshold != 256 {
			t.Errorf("StrassenThreshold = %d, want 256", updated.StrassenThreshold)
		}
	})

	t.Run("Invalid profile", func(t *testing.T) {
		t.Parallel()
		tmpDir := t.TempDir()
		profilePath := tmpDir + "/invalid.json"

		// Create an invalid profile (empty file)
		if err := os.WriteFile(profilePath, []byte("{}"), 0600); err != nil {
			t.Fatalf("Failed to write invalid profile: %v", err)
		}

		cfg := config.AppConfig{}
		_, success := LoadCachedCalibration(cfg, profilePath)
		if success {
			t.Error("Should return false for invalid profile")
		}
	})
}

func TestAutoCalibrateWithProfile(t *testing.T) {
	t.Parallel()

	t.Run("Load existing profile", func(t *testing.T) {
		t.Parallel()
		tmpDir := t.TempDir()
		profilePath := tmpDir + "/profile.json"

		// Create a valid profile
		profile := NewProfile()
		profile.OptimalParallelThreshold = 4096
		profile.OptimalFFTThreshold = 1000000
		profile.OptimalStrassenThreshold = 256
		if err := profile.SaveProfile(profilePath); err != nil {
			t.Fatalf("Failed to save profile: %v", err)
		}

		registry := map[string]fibonacci.Calculator{
			"fast": &MockCalculator{name: "fast"},
		}

		cfg := config.AppConfig{
			Timeout: 1 * time.Second,
		}

		var outBuf bytes.Buffer
		ctx := context.Background()
		updated, ok := AutoCalibrateWithProfile(ctx, cfg, &outBuf, registry, profilePath)

		if !ok {
			t.Error("AutoCalibrateWithProfile should succeed with existing profile")
		}
		if updated.Threshold != 4096 {
			t.Errorf("Threshold = %d, want 4096", updated.Threshold)
		}
		output := outBuf.String()
		if !strings.Contains(output, "Using cached calibration") {
			t.Errorf("Output should mention cached calibration. Got: %s", output)
		}
	})

	t.Run("Quick calibration fallback", func(t *testing.T) {
		t.Parallel()
		tmpDir := t.TempDir()
		profilePath := tmpDir + "/profile.json"

		registry := map[string]fibonacci.Calculator{
			"fast": &MockCalculator{name: "fast"},
		}

		cfg := config.AppConfig{
			Timeout: 5 * time.Second,
		}

		var outBuf bytes.Buffer
		ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
		defer cancel()

		updated, ok := AutoCalibrateWithProfile(ctx, cfg, &outBuf, registry, profilePath)

		// Quick calibration may succeed or timeout
		if ok {
			if updated.Threshold == 0 {
				t.Error("Threshold should be set after quick calibration")
			}
			output := outBuf.String()
			if !strings.Contains(output, "Quick calibration") && !strings.Contains(output, "calibration") {
				t.Errorf("Output should mention calibration. Got: %s", output)
			}
		}
	})

	t.Run("Full calibration fallback", func(t *testing.T) {
		t.Parallel()
		tmpDir := t.TempDir()
		profilePath := tmpDir + "/profile.json"

		registry := map[string]fibonacci.Calculator{
			"fast":   &MockCalculator{name: "fast"},
			"matrix": &MockCalculator{name: "matrix"},
		}

		cfg := config.AppConfig{
			Timeout: 5 * time.Second,
		}

		var outBuf bytes.Buffer
		ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
		defer cancel()

		updated, ok := AutoCalibrateWithProfile(ctx, cfg, &outBuf, registry, profilePath)

		// Full calibration may succeed or timeout
		if ok {
			if updated.Threshold == 0 {
				t.Error("Threshold should be set after full calibration")
			}
		}
	})

	t.Run("No fast calculator", func(t *testing.T) {
		t.Parallel()
		tmpDir := t.TempDir()
		profilePath := tmpDir + "/profile.json"

		registry := map[string]fibonacci.Calculator{} // Empty

		cfg := config.AppConfig{
			Timeout:   1 * time.Second,
			Threshold: 0, // Explicitly set to 0
		}

		var outBuf bytes.Buffer
		ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)
		defer cancel()

		updated, ok := AutoCalibrateWithProfile(ctx, cfg, &outBuf, registry, profilePath)

		// QuickCalibrate might succeed even without fast calculator (it uses bigfft directly)
		// So we check that if it fails, the config remains unchanged
		if !ok {
			if updated.Threshold != cfg.Threshold {
				t.Errorf("Config should remain unchanged on failure. Threshold = %d, want %d",
					updated.Threshold, cfg.Threshold)
			}
		} else {
			// If it succeeded (via QuickCalibrate), thresholds should be set
			if updated.Threshold == 0 {
				t.Error("If calibration succeeded, threshold should be set")
			}
		}
	})
}

func TestCalibrationRunner(t *testing.T) {
	t.Parallel()
	ctx := context.Background()
	runner := newCalibrationRunner(ctx, 1*time.Second)
	calc := &MockCalculator{name: "fast"}

	// Test findBestParallelThreshold
	bestPar, parDur := runner.findBestParallelThreshold(calc, 4096)
	if bestPar == 0 {
		t.Error("findBestParallelThreshold should return a non-zero threshold")
	}
	if parDur == 0 {
		t.Error("findBestParallelThreshold should return a non-zero duration")
	}

	// Test findBestFFTThreshold
	bestFFT, fftDur := runner.findBestFFTThreshold(calc, bestPar, 1000000)
	if bestFFT == 0 {
		t.Error("findBestFFTThreshold should return a non-zero threshold")
	}
	if fftDur == 0 {
		t.Error("findBestFFTThreshold should return a non-zero duration")
	}

	// Test findBestStrassenThreshold
	bestStr, strDur := runner.findBestStrassenThreshold(calc, bestPar, 256)
	if bestStr == 0 {
		t.Error("findBestStrassenThreshold should return a non-zero threshold")
	}
	if strDur == 0 {
		t.Error("findBestStrassenThreshold should return a non-zero duration")
	}
}

func TestApplyCalibrationResults(t *testing.T) {
	t.Parallel()
	cfg := config.AppConfig{}
	updated, ok := applyCalibrationResults(cfg, 4096, 10*time.Millisecond, 1000000, 10*time.Millisecond, 256, 10*time.Millisecond)
	if !ok {
		t.Error("applyCalibrationResults should return true")
	}
	if updated.Threshold != 4096 {
		t.Errorf("Threshold = %d, want 4096", updated.Threshold)
	}
}
